// TTS Web Worker for local text-to-speech synthesis
const ttsModule = null
let isInitialized = false

// Initialize TTS module
async function initTTS() {
  if (isInitialized) return

  try {
    console.log("Initializing TTS module...")

    // Simulate loading Coqui TTS model
    await new Promise((resolve) => setTimeout(resolve, 800))

    isInitialized = true
    console.log("TTS module initialized")
  } catch (error) {
    console.error("Failed to initialize TTS:", error)
    throw error
  }
}

// Synthesize speech from text
async function synthesizeSpeech(text) {
  if (!isInitialized) {
    await initTTS()
  }

  try {
    console.log("Synthesizing speech for:", text)

    // Simulate speech synthesis
    await new Promise((resolve) => setTimeout(resolve, 300))

    // Create a simple audio buffer (in real implementation, this would be generated by TTS)
    const sampleRate = 22050
    const duration = Math.max(1, text.length * 0.1) // Rough duration estimate
    const samples = Math.floor(sampleRate * duration)

    // Generate simple sine wave as placeholder audio
    const audioBuffer = new Float32Array(samples)
    const frequency = 200 + Math.random() * 200 // Vary frequency

    for (let i = 0; i < samples; i++) {
      audioBuffer[i] = Math.sin((2 * Math.PI * frequency * i) / sampleRate) * 0.3
    }

    // Convert to WAV format
    const wavBuffer = createWavBuffer(audioBuffer, sampleRate)

    return wavBuffer
  } catch (error) {
    console.error("Speech synthesis error:", error)
    throw error
  }
}

// Create WAV file buffer from audio data
function createWavBuffer(audioData, sampleRate) {
  const length = audioData.length
  const buffer = new ArrayBuffer(44 + length * 2)
  const view = new DataView(buffer)

  // WAV header
  const writeString = (offset, string) => {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i))
    }
  }

  writeString(0, "RIFF")
  view.setUint32(4, 36 + length * 2, true)
  writeString(8, "WAVE")
  writeString(12, "fmt ")
  view.setUint32(16, 16, true)
  view.setUint16(20, 1, true)
  view.setUint16(22, 1, true)
  view.setUint32(24, sampleRate, true)
  view.setUint32(28, sampleRate * 2, true)
  view.setUint16(32, 2, true)
  view.setUint16(34, 16, true)
  writeString(36, "data")
  view.setUint32(40, length * 2, true)

  // Convert float samples to 16-bit PCM
  let offset = 44
  for (let i = 0; i < length; i++) {
    const sample = Math.max(-1, Math.min(1, audioData[i]))
    view.setInt16(offset, sample * 0x7fff, true)
    offset += 2
  }

  return buffer
}

// Handle messages from main thread
self.onmessage = async (event) => {
  const { type, text } = event.data

  try {
    switch (type) {
      case "synthesize":
        const audioBuffer = await synthesizeSpeech(text)
        self.postMessage({
          type: "synthesis-complete",
          data: { audioBuffer },
        })
        break

      case "init":
        await initTTS()
        self.postMessage({
          type: "init-complete",
        })
        break

      default:
        throw new Error(`Unknown message type: ${type}`)
    }
  } catch (error) {
    self.postMessage({
      type: "error",
      error: error.message,
    })
  }
}

// Initialize on worker startup
initTTS().catch(console.error)
